_e3f‍.x([["Patient",()=>Patient],["Patients",()=>Patients]]);// different mesh colors for different clusters
let pointColors = { 'I': 0x00ff00, // green
                    'U': 0xff0000, //red
                  'CHN': 0xffff00, //yellow
                    'L': 0x0000ff,
                    'BG':0x00ffff, //cyan
                    'PCF': 0xec8254, //green
                    'YTH': 0x5e0b3d,
                    'LCM': 0xbe6d49,
                    'SAH': 0xF0FFF0,
                    'GAOG':0x9370DB,
                    'MHD': 0xBDB76B,
                    'SAFRA': 0xFFF0F5,
                    'WT': 0x9ACD32,
                    'LCM': 0x1E90FF,
                    'MAM': 0xFF4500,
                    'RG': 0x66CDAA,
                    'HER': 0xFFA07A,
                    'COS': 0xF0F8FF,
                    'WR': 0xC0C0C0,
                    'SPC':0xec8254,
                    'DCIS': 0xec8254,
                    'TWB': 0xec8254,
                    'SDP': 0xec8254
                };
                

const pointZtrans = { 'I': null,
                    'U': null,
                  'CHN': null, 
                    'L': null,
                    'BG':null,
                    'PCF':null,
                    'YTH':null,
                    'LCM':null,
                    'SAH':null,
                    'GAOG':null,
                    'MHD':null,
                    'SAFRA':null,
                    'WT':null,
                    'LCM':null,
                    'MAM':null,
                    'RG':null,
                    'HER':null,
                    'COS':null,
                    'WR':null,
                    'SPC':null,
                    'DCIS':null,
                    'TWB':null,
                    'SDP':null                    
                };
let num;
for (const key of Object.keys(pointZtrans)) {
    pointZtrans[key] = num;
    num += 1;
}
class Patient {
    constructor(currentDateId, cn, data){
        this.caseNumber = cn;
        this.age = data.Age;
        this.gender = data.Gender;
        this.nat = data.Nationality;
        this.hosp = data.Hospital;
        this.links=data.Links;
        this.clus = data.Cluster;
        this.dis=data.Discharged;
        this.dead = data.Death;
        this.th = data.TravelHistory;
        this.x = this.age*(6/88) - 3 ;
        this.y = this.gender=='M' ? Math.random()* 2 : Math.random() * (-2);
        this.z = this.links&&(this.clus!='U') ? pointZtrans[this.clus]*0.25 - 2 :(Math.random()-0.5)*4 ;//(Math.random()-0.5)*4;
        this.translate = (new THREE.Vector3(this.x, this.y, this.z)).setLength((currentDateId-1)*0.09);
        // this.links&&this.clus ? pointZtrans[this.clus]*0.25 - 2 :(Math.random()-0.5)*4 
        this.geom; 
        this.linklines = [];
    }

    create() { 
        // radius, width segments, height segments
        let geometry = new THREE.SphereBufferGeometry(0.03,12,12);
        geometry.translate(this.translate.x, this.translate.y, this.translate.z);
        let material = new THREE.MeshBasicMaterial();
        material.color.set(pointColors[this.clus]);
        // material.emissive.set(pointColors[this.clus]);
        // material.emissiveIntensity = 0.3;
        this.geom = new THREE.Mesh(geometry, material);
    } 

    createLink(start, end) {
        let points = [start, end];
        let mat = new THREE.LineBasicMaterial({color: pointColors[this.clus]});
        let geo = new THREE.BufferGeometry().setFromPoints(points);
        this.linklines.push(new THREE.Line(geo, mat));
    }
}

class Patients {
    constructor(parent) {
        this.p = parent;
        this.allPatients = [];
        this.data;
    }

    addPatient(currentDateId, cn, data) {
        let newPatient = new Patient(currentDateId, cn, data);
        newPatient.create();

        if (newPatient.links!='') {
            let linkNumbers = newPatient.links.split(",");
            for (let linkN of linkNumbers) {
                let linkedPatient = this.allPatients[parseInt(linkN)-1];
                if (linkedPatient) {
                    newPatient.createLink(linkedPatient.translate, newPatient.translate);
                }
            }
        }
        this.allPatients.push(newPatient);
    }

    display(currentDateId) {
        let totalCases = parseInt(this.data[currentDateId]['totalCases'])
     
        for (let i = 0; i<totalCases; i++) {
            this.p.add(this.allPatients[i].geom);
            if (this.allPatients[i].linklines.length!=0){
                for (let line of this.allPatients[i].linklines) {
                    this.p.add(line);
                }
            }
        }
        if (this.allPatients.length>totalCases) {
            let removePatients = this.allPatients.slice(totalCases, this.allPatients.length+1);
            for (let patient of removePatients) {
                this.p.remove(patient.geom);
                if (patient.linklines.length!=0){
                    for (let line of patient.linklines){
                        this.p.remove(line);
                    }
                }
            }
        }
        
    }
}   


